#!/bin/bash

# Usage: devlog [flag] <command_or_comment>
# Example: devlog -i sudo apt install curl
#          devlog -b make build
#          devlog -r ./myapp
#          devlog -c git config --global user.name "Name"
#          devlog -n "This is a comment or note"

# Default file
LOG_FILE="devlog.md"
TEMP_FILE="${LOG_FILE}.tmp"

# Check if file exists; if not, initialize with basic structure including timestamp, directory name, and pre-defined sections (Install, Config, Comments only)
if [ ! -f "$LOG_FILE" ]; then
    TIMESTAMP=$(date +"%Y-%m-%d %H:%M:%S")
    CURRENT_DIR=$(basename "$(pwd)")
    echo "# Devlog for $CURRENT_DIR" > "$LOG_FILE"
    echo "A log of development commands and notes. Created on $TIMESTAMP." >> "$LOG_FILE"
    echo "" >> "$LOG_FILE"
    echo "## Comments" >> "$LOG_FILE"
    echo "" >> "$LOG_FILE"
    echo "## Config" >> "$LOG_FILE"
    echo "" >> "$LOG_FILE"
    echo "## Install" >> "$LOG_FILE"
    echo "" >> "$LOG_FILE"

fi

# Parse flag and command/comment
FLAG=$1
shift  # Remove flag from args
INPUT="$@"  # Renamed from COMMAND to INPUT for clarity (could be command or comment)

# Ensure input was provided
if [ -z "$INPUT" ]; then
    echo "Error: No command or comment provided. Usage: devlog [flag] <command_or_comment>"
    exit 1
fi

# Determine section and behavior based on flag
case "$FLAG" in
    -i)
        SECTION="Install"
        # Execute the command and capture status
        echo "Executing: $INPUT"
        eval "$INPUT"
        EXIT_STATUS=$?
        # Prepare the new entry content (no timestamp)
        NEW_ENTRY="\n\`\`\`bash\n$INPUT\n\`\`\`\n"
        ;;
    -c)  
        SECTION="Config"
        # Execute the command and capture status
        echo "Executing: $INPUT"
        eval "$INPUT"
        EXIT_STATUS=$?
        # Prepare the new entry content (no timestamp)
        NEW_ENTRY="\n\`\`\`bash\n$INPUT\n\`\`\`\n"
        ;;
    -b)
        SECTION="Build"
        # Execute the command and capture status
        echo "Executing: $INPUT"
        eval "$INPUT"
        EXIT_STATUS=$?
        # Prepare the new entry content (no timestamp)
        NEW_ENTRY="\n\`\`\`bash\n$INPUT\n\`\`\`\n"
        ;;
    -r)
        SECTION="Run"
        # Execute the command and capture status
        echo "Executing: $INPUT"
        eval "$INPUT"
        EXIT_STATUS=$?
        # Prepare the new entry content (no timestamp)
        NEW_ENTRY="\n\`\`\`bash\n$INPUT\n\`\`\`\n"
        ;;
    -n)
        SECTION="Comments"
        # No execution for comments
        # Prepare the new entry content as a Markdown paragraph, separated by a horizontal rule for distinction (minimal newlines)
        NEW_ENTRY="\n- $INPUT"
        ;;
    *)
        echo "Error: Unknown flag '$FLAG'. Supported: -i (install), -c (config), -b (build), -r (run), -n (comments)."
        exit 1
        ;;
esac

# Use awk to insert the new entry at the end of the correct section
awk -v section="## $SECTION" -v new_entry="$NEW_ENTRY" '
{
    lines[NR] = $0  # Store all lines in an array
}
END {
    section_line = -1
    # Find the starting line of the target section
    for (i = 1; i <= NR; i++) {
        if (lines[i] == section) {
            section_line = i
            break
        }
    }
    
    if (section_line == -1) {
        # Section not found: Print entire file, then append new section + entry
        for (i = 1; i <= NR; i++) print lines[i]
        print "\n" section
        print new_entry
    } else {
        # Find the end of this section: line before next ## or EOF
        end_line = NR + 1
        for (i = section_line + 1; i <= NR; i++) {
            if (lines[i] ~ /^## /) {
                end_line = i
                break
            }
        }
        # Print lines up to the end of the section
        for (i = 1; i < end_line; i++) print lines[i]
        # Insert the new entry
        print new_entry
        # Print the remaining lines (after the insertion point)
        for (i = end_line; i <= NR; i++) print lines[i]
    }
}' "$LOG_FILE" > "$TEMP_FILE"

# Replace the original file with the updated one
mv "$TEMP_FILE" "$LOG_FILE" || { echo "Error: Failed to update $LOG_FILE"; exit 1; }

echo "Entry appended to $LOG_FILE under '$SECTION' section."
